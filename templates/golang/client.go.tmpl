package openapi

import (
    "net/http"
    "strings"
    "io"
)


type ClientOption func(*Client)

func NewClient(opts ...ClientOption) *Client {
    client := &Client{}

    for _, opt := range opts {
        opt(client)
    }

    return client
}

type Client struct {
    httpClient http.Client
}

{{ range . }}
// {{.Name}} ...
func(c *Client) {{ .Name }}({{.ToArgs}}) (interface{}, error) {
    path := "{{.Path}}"
    {{ if .HasPathParams}}
    {{ range .PathParams }}
    path = strings.ReplaceAll(path, "{{.Template}}", {{convertToString .OriginalName .Schema }})
    {{ end }}
    {{- end -}}

    req, err := c.newRequest("{{.Method}}", path, nil)
    if err != nil {
        return nil, err
    }

    {{ if .HasQueryParams }}
    query := req.URL.Query()
    {{ range .QueryParams }}
    query.Add("{{.OriginalName}}", {{convertToString .Name .Schema }})
    {{ end }}
    {{- end -}}

    {{ if .HasHeaderParams }}
    {{ range .QueryParams }}
    req.Header().Add("{{.OriginalName}}", {{convertToString .Name .Schema }})
    {{ end }}
    {{- end -}}

    resp, err := c.sendRequest(req)
    if err != nil {
        return nil, err
    }

    return resp, nil
}
{{ if .HasOtherParams}}
type {{.Name}}Params struct {
    {{ range .OtherParams -}}
    {{.Name}} {{detectType .Schema}}
    {{ end }}
}
{{ end }}
{{ end }}

func (c *Client) newRequest(method string, path string, reader io.Reader) (*http.Request, error) {
    return http.NewRequest(method, path, reader)
}

func (c *Client) sendRequest(req *http.Request) (*http.Response, error) {
    return c.httpClient.Do(req)
}